#!/usr/bin/python
#
#  File: helena-generate-config
#
#  Parse arguments from the command line and generate the appropriate
#  C configuration file.
#

import datetime
from datetime import date
from datetime import datetime
from datetime import time
import os
import re
import socket
import sys
import xml.dom.minidom

VERSION = "2.3"
DATE    = "April 1, 2013"

#  actions
EXPLORE     = "EXPLORE"
SIMULATE    = "SIMULATE"
BUILD_GRAPH = "BUILD-GRAPH"
CHECK       = "CHECK"

#  search algorithms
BFS         = "BFS"
DFS         = "DFS"
DBFS        = "DBFS"
DDFS        = "DDFS"
FRONTIER    = "FRONTIER"
RWALK       = "RWALK"
DELTA_DDD   = "DELTA-DDD"

#  trace types
FULL        = "FULL"
EVENTS      = "EVENTS"
STATE       = "STATE"

#  property types
LTL         = "LTL"
STATE       = "STATE"
DEADLOCK    = "DEADLOCK"

def removeDashes(s):
    if s[1] == '-':
        return s[2:]
    else:
        return s[1:]

def parseArgument(arg):
    S = re.search
    if S("^-(-)?[a-zA-Z\-]+(=.+)?$", arg):
        arg = removeDashes(arg)
        l = arg.split("=", 1)
        if len(l) == 2:
            return (l[0], l[1])
        else:
            return (l[0], None)
    else:
        return (None, None)

def parseIntArgument(val, shortForm, longForm):
    S = re.search
    if S("^-" + shortForm + "=", val) or S("^--" + longForm + "=", val):
        l = val.split("=")
        if len(l) <> 2:
            return None
        else:
            try:
                result = int(l[1])
                return result
            except ValueError:
                return None

def parseCheckArgument(val):
    S = re.search
    if not(S("^CHECK-", val.upper())):
        return (False, None)
    else:
        l = val.split("-")
        if len(l) <> 2:
            return (False, None)
        else:
            return (True, l[1])

def printVersion():
    print "helena " + VERSION + " --- " + DATE

def printHelp():
    print "usage: helena [option] ... [option] my-net.lna"
    print ""
    print "General options"
    print "  -h   --help"
    print "  -V   --version"
    print "  -v   --verbose"
    print "  -N   --action={EXPLORE|SIMULATE|BUILD-GRAPH|CHECK-prop}"
    print "  -p   --property-file=FILE"
    print "  -md  --model-directory=DIRECTORY"
    print ""
    print "Search and storage options"
    print "  -A   --algo={BFS|DBFS|DFS|DDFS|FRONTIER|DELTA-DDD|RWALK}"
    print "  -t   --hash-size=H"
    print "  -W   --workers=WORKERS"
    print "  -cs  --candidate-set-size=N"
    print "  -dc  --ddfs-comm-strategy={K<N>|M|D<N>} ... {K<N>|M|D<N>}"
    print "  -mf  --machine-file=FILE"
    print ""
    print "Reduction techniques"
    print "  -H   --hash-compaction"
    print "  -P   --partial-order[={0|1}]"
    print "  -S   --state-caching[={0|1}]"
    print ""
    print "Search limits"
    print "  -ml  --memory-limit=N"
    print "  -tl  --time-limit=N"
    print "  -sl  --state-limit=N"
    print ""
    print "Model options"
    print "  -d   --define=SYMBOL-NAME"
    print "  -a   --capacity=N"
    print "  -r   --run-time-checks[={0|1}]"
    print "  -L   --link=OBJECT-FILE"
    print "  -m   --parameter=p=i"
    print ""
    print "Output"
    print "  -o   --report-file=FILE-NAME"
    print "  -tr  --trace-type={FULL|EVENTS|STATE}"

class Config:        

    def __init__(self):
        self.verbose = False
        self.version = False
        self.partialOrder = False
        self.stateCaching = False
        self.hashCompaction = False
        self.workers = 1
        self.capacity = 1
        self.candidateSetSize = 100000
        self.memoryLimit = 0
        self.timeLimit = 0
        self.stateLimit = 0
        self.hashSize = 22
        self.algo = DFS
        self.traceType = FULL
        self.directory = None
        self.symbols = []
        self.action = EXPLORE
        self.runTimeChecks = True
        self.inFile = None
        self.inFileExt = None
        self.prop = None
        self.propFile = None
        self.propType = None
        self.propositions = []
        self.parameters = []
        self.ddfsCommStrat = []

    #  correct inconsistencies in received arguments
    def correct(self):
        if self.action == BUILD_GRAPH:
            self.algo = DELTA_DDD
            self.prop = None
            self.stateCaching = False
            self.hashCompaction = False
            self.partialOrder = False
            self.workers = 1
        elif self.action == CHECK and self.propType == LTL:
            self.algo = DFS
            if self.traceType == STATE:
                self.traceType = FULL
        elif self.action == SIMULATE:
            self.runTimeChecks = True
        if self.algo == RWALK:
            self.stateCaching = False
            self.hashCompaction = False
            self.partialOrder = False
        elif self.algo == FRONTIER:
            self.stateCaching = False
            self.hashCompaction = False
            self.workers = 1
        elif self.algo == DELTA_DDD:
            self.stateCaching = False
            self.hashCompaction = False
            self.partialOrder = False
        elif self.algo == BFS:
            self.hashCompaction = False
            self.stateCaching = False
        elif self.algo == DDFS:
            self.partialOrder = False
        elif self.algo == DBFS:
            self.partialOrder = False

    def openFile(self, name, mode):
        if self.directory is None:
            return open(name, mode)
        else:
            return open(self.directory + os.sep + name, mode)

    def generateConfigFile(self):
        f = self.openFile("config.h", "w")
        W = f.write
        now = datetime.now()
        W("#ifndef LIB_CONFIG\n")
        W("#define LIB_CONFIG\n")
        W("\n")
        W("#define CFG_MODEL_CONFIG\n")
        W("#define CFG_REPORT_FILE \"report.xml\"\n")
        W("#define CFG_RG_REPORT_FILE \"rg-report.xml\"\n")
        W("#define CFG_GRAPH_FILE \"graph.dat\"\n")
        W("#define CFG_WITH_OBSERVER\n")
        W("#define CFG_DATE \"" + \
               now.strftime("%B, %d, %Y at %H:%M:%S") + "\"\n")
        W("#define CFG_FILE_PATH \"" + os.path.realpath(self.inFile) + "\"\n")
        if self.inFileExt == ".lna":
            W("#define CFG_LANGUAGE \"helena\"\n")
            W("#define CFG_LANGUAGE_LNA\n")
            W("#define CFG_EVENT_UNDOABLE\n")
            W("#define CFG_MODEL_HAS_GRAPH_ROUTINES\n")
        elif self.inFileExt == ".dve":
            (model, _) = os.path.splitext(os.path.basename(self.inFile))
            if model == "": model = "model"
            W("#define CFG_MODEL_NAME \"" + model + "\"\n")
            W("#define CFG_LANGUAGE \"dve\"\n")
            W("#define CFG_LANGUAGE_DVE\n")
        if self.inFileExt in [ ".lna", ".dve" ]:
            W("#define CFG_USE_HELENA_HEAPS\n")
        if self.verbose:
            W("#define CFG_VERBOSE\n")

        #  search algorithm
        if self.algo == FRONTIER:
            W("#define CFG_ALGO_FRONTIER\n")
            W("#define CFG_HASH_STORAGE\n")
        elif self.algo == BFS:
            W("#define CFG_ALGO_BFS\n")
            W("#define CFG_HASH_STORAGE\n")
        elif self.algo == DFS:
            W("#define CFG_ALGO_DFS\n")
            W("#define CFG_HASH_STORAGE\n")
        elif self.algo == DDFS:
            W("#define CFG_ALGO_DDFS\n")
            W("#define CFG_HASH_STORAGE\n")
            if len(self.ddfsCommStrat) > 0:
                W("#define CFG_DDFS_COMM_STRAT\n")
        elif self.algo == DBFS:
            W("#define CFG_ALGO_DBFS\n")
            W("#define CFG_HASH_STORAGE\n")
            W("#define CFG_DISTRIBUTED\n")
                
            K = False
            D = False
            M = False
            for (strat, val) in self.ddfsCommStrat:
                if strat == "K" and not K:
                    W("#define CFG_DDFS_COMM_STRAT_K " + str(val) + "\n")
                    K = True
                elif strat == "D" and not D:
                    W("#define CFG_DDFS_COMM_STRAT_DEGREE " + str(val) + "\n")
                    D = True
                elif strat == "M" and not M:
                    W("#define CFG_DDFS_COMM_STRAT_MINE\n")
                    M = True
        elif self.algo == DELTA_DDD:
            W("#define CFG_ALGO_PD4\n")
            W("#define CFG_PD4_STORAGE\n")
        elif self.algo == RWALK:
            W("#define CFG_ALGO_RWALK\n")
        W("#define CFG_PD4_CAND_SET_SIZE " + str(self.candidateSetSize) + "\n")

        #  state caching
        if self.stateCaching:
            W("#define CFG_STATE_CACHING\n")
            W("#define CFG_STATE_CACHING_GC_THRESHOLD 50\n")
            W("#define CFG_STATE_CACHING_GC_PERCENT   0.01\n")

        #  search limits
        if self.memoryLimit != 0:
            W("#define CFG_MEMORY_LIMITED\n")
            W("#define CFG_MAX_MEMORY " + str(self.memoryLimit) + "\n")
        if self.timeLimit != 0:
            W("#define CFG_TIME_LIMITED\n")
            W("#define CFG_MAX_TIME " + str(self.timeLimit) + "\n")
        if self.stateLimit != 0:
            W("#define CFG_STATE_LIMITED\n")
            W("#define CFG_MAX_STATE " + str(self.stateLimit) + "\n")

        #  hash table
        W("#define CFG_HASH_SIZE " + str(pow(2, self.hashSize)) + "\n")
        W("#define CFG_HASH_SIZE_M " + \
          str(pow(2, self.hashSize) - 1) + "\n")
        W("#define CFG_HASH_SIZE_BITS " + str(self.hashSize) + "\n")
        if self.hashCompaction:
            W("#define CFG_HASH_COMPACTION\n")
        W("#define CFG_HASH_COMPACTION_KEYS 1\n")

        #  action to perform
        if self.action == EXPLORE:
            W("#define CFG_ACTION_EXPLORE\n")
        elif self.action == BUILD_GRAPH:
            W("#define CFG_ACTION_BUILD_RG\n")
        elif self.action == SIMULATE:
            W("#define CFG_ACTION_SIMULATE\n")
        elif self.action == CHECK:
            W("#define CFG_PROPERTY \"" + self.prop + "\"\n")
            if self.propType == LTL:
                W("#define CFG_ACTION_CHECK_LTL\n")
            elif self.propType == STATE:
                W("#define CFG_ACTION_CHECK_SAFETY\n")
            elif self.propType == DEADLOCK:
                W("#define CFG_ACTION_CHECK_SAFETY\n")

        #  trace mode
        W("#define CFG_TRACE_" + self.traceType + "\n")
        if self.traceType != STATE:
            W("#define CFG_WITH_TRACE\n")

        #  partial order reduction
        if self.partialOrder:
            W("#define CFG_POR\n")
            if self.propType is not None and \
               self.propType != DEADLOCK:
                W("#define CFG_PROVISO\n")
                
        #  parallel mode
        W("#define CFG_NO_WORKERS " + str(self.workers) + "\n")
        if self.workers > 1:
            W("#define CFG_PARALLEL\n")

        #  distributed mode
        if self.algo in [ DBFS, DDFS ]:
            W("#define CFG_DISTRIBUTED\n")

        #  state attributes
        bitw = 0
        W("#define CFG_ATTRIBUTE_CYAN\n")
        W("#define CFG_ATTRIBUTE_CYAN_POS " + str(bitw) + "\n")
        W("#define CFG_ATTRIBUTE_CYAN_WIDTH " + str(self.workers) + "\n")
        bitw = bitw + self.workers
        W("#define CFG_ATTRIBUTE_BLUE\n")
        W("#define CFG_ATTRIBUTE_BLUE_POS " + str(bitw) + "\n")
        W("#define CFG_ATTRIBUTE_BLUE_WIDTH 1\n")
        bitw = bitw + 1
        if not self.hashCompaction:
            W("#define CFG_ATTRIBUTE_CHAR_LEN\n")
            W("#define CFG_ATTRIBUTE_CHAR_LEN_POS " + str(bitw) + "\n")
            W("#define CFG_ATTRIBUTE_CHAR_LEN_WIDTH 16\n")
            bitw = bitw + 16
        if self.action == CHECK and self.propType == LTL:
            W("#define CFG_ATTRIBUTE_PINK\n")
            W("#define CFG_ATTRIBUTE_PINK_POS " + str(bitw) + "\n")
            W("#define CFG_ATTRIBUTE_PINK_WIDTH " + \
              str(self.workers) + "\n")
            bitw = bitw + self.workers
            W("#define CFG_ATTRIBUTE_RED\n")
            W("#define CFG_ATTRIBUTE_RED_POS " + str(bitw) + "\n")
            W("#define CFG_ATTRIBUTE_RED_WIDTH 1\n")
            bitw = bitw + 1
        if self.stateCaching:
            W("#define CFG_ATTRIBUTE_GARBAGE\n")
            W("#define CFG_ATTRIBUTE_GARBAGE_POS " + str(bitw) + "\n")
            W("#define CFG_ATTRIBUTE_GARBAGE_WIDTH 1\n")
            bitw = bitw + 1
            W("#define CFG_ATTRIBUTE_REFS\n")
            W("#define CFG_ATTRIBUTE_REFS_POS " + str(bitw) + "\n")
            W("#define CFG_ATTRIBUTE_REFS_WIDTH 8\n")
            bitw = bitw + 8
            
        charw = bitw / 8
        if bitw % 8 != 0:
            charw = charw + 1
        W("#define CFG_ATTRIBUTES_CHAR_WIDTH " + str(charw) + "\n")

        W("\n#endif  /*  LIB_CONFIG  */\n")
        f.close()

    def handleNumericalOption(self, attr, val):
        try:
            if val is None:
                return False
            i = int(val)
            setattr(self, attr, i)
            return True
        except ValueError:
            return False

    def handleStringOption(self, attr, val):
        if val is None:
            return False
        else:
            if attr is not None:
                setattr(self, attr, val)
            return True

    def handleEnumOption(self, attr, val, okVal):
        if val is None:
            return False
        if val.upper() in okVal:
            setattr(self, attr, val.upper())
            return True
        else:
            return False
        
    def parseFromCommandLine(self):
        S = re.search
        for arg in sys.argv[1 : len(sys.argv) - 2]:
            recognized = True
            (opt, val) = parseArgument(arg)

            #  options with no value
            if (opt, val) in [("v", None),("verbose", None) ]:
                self.verbose = True
            elif(opt, val) in [("V", None),("version", None) ]:
                printVersion()
                exit(0)
            elif(opt, val) in [("h", None),("help", None) ]:
                printHelp()
                exit(0)
                
            #  boolean options
            elif opt in [ "P", "partial-order" ]:
                self.partialOrder =(val is None) or val == "1"
            elif opt in [ "r", "run-time-checks" ]:
                self.runTimeChecks =(val is None) or val == "1"
            elif opt in [ "S", "state-caching" ]:
                self.stateCaching =(val is None) or val == "1"
            elif opt in [ "H", "hash-compaction" ]:
                self.hashCompaction =(val is None) or val == "1"

            #  numerical options
            elif opt in [ "W", "workers" ]:
                recognized = self.handleNumericalOption("workers", val)
            elif opt in [ "a", "capacity" ]:
                recognized = self.handleNumericalOption("capacity", val)
            elif opt in [ "cs", "candidate-set-size" ]:
                recognized = self.handleNumericalOption("candidateSetSize",
                                                         val)
            elif opt in [ "t", "hash-size" ]:
                recognized = self.handleNumericalOption("hashSize", val)
                if self.hashSize > 32:
                    self.hashSize = 32
            elif opt in [ "ml", "memory-limit" ]:
                recognized = self.handleNumericalOption("memoryLimit", val)
            elif opt in [ "tl", "time-limit" ]:
                recognized = self.handleNumericalOption("timeLimit", val)
            elif opt in [ "sl", "state-limit" ]:
                recognized = self.handleNumericalOption("stateLimit", val)

            #  string options
            elif opt in [ "d", "define" ]:
                recognized = self.handleStringOption(None, val)
                if recognized:
                    self.symbols.append(val)
            elif opt in [ "L", "link" ]:
                recognized = self.handleStringOption("link", val)
            elif opt in [ "p", "property-file" ]:
                recognized = self.handleStringOption("propertyFile", val)
            elif opt in [ "o", "report-file" ]:
                recognized = self.handleStringOption("reportFile", val)
            elif opt in [ "md", "model-directory" ]:
                recognized = True
            elif opt in [ "mf", "machine-file" ]:
                recognized = True
            elif opt in [ "m", "parameter" ]:
                recognized = self.handleStringOption(None, val)
                if recognized:
                    l = val.split("=")
                    recognized = len(l) == 2
                    if recognized:
                        self.parameters.append(val)

            #  enum options
            elif opt in [ "A", "algo" ]:
                recognized = self.handleEnumOption \
                    ("algo", val, [BFS, DBFS, DFS, DDFS, FRONTIER, \
                                   DELTA_DDD, RWALK])
            elif opt in [ "tr", "trace-type" ]:
                recognized = self.handleEnumOption \
                    ("traceType", val, [FULL, EVENTS, STATE])
            elif opt in [ "N", "action" ]:
                self.prop = None
                recognized = self.handleEnumOption \
                    ("action", val, [SIMULATE, EXPLORE, BUILD_GRAPH])
                if not recognized:
                    (recognized, p) = parseCheckArgument(val)
                    if recognized:
                        self.action = CHECK
                        self.prop = p

            #  special case options
            elif opt in [ "dc", "ddfs-comm-strategy" ]:
                for s in val.split(","):
                    recognized = True
                    if S("^K[0-9]*", s):
                        self.ddfsCommStrat.append(("K", int(s[1:])))
                    elif S("^D[0-9]*", s):
                        self.ddfsCommStrat.append(("D", int(s[1:])))
                    elif s == "M":
                        self.ddfsCommStrat.append(("M", None))
                    else:
                        recognized = False

            else:
                recognized = False
            if not recognized:
                print "warning: \"" + arg + "\" is not a valid option"
        if len(sys.argv) >= 2:
            self.inFile = sys.argv[len(sys.argv) - 2]
            (f, self.inFileExt) = os.path.splitext(self.inFile)
            if self.propFile is None:
                self.propFile = f + ".prop" + self.inFileExt
        if len(sys.argv) >= 3:
            self.directory = sys.argv[len(sys.argv) - 1]

    def generatePropertyCode(self):
        if self.action != CHECK \
                or self.prop is None \
                or self.propFile is None:
            f = self.openFile("prop.h", "w")
            f.close()
            f = self.openFile("prop.c", "w")
            f.close()
        else:
            cmd = "helena-generate-property "
            cmd = cmd + " " + self.prop + " " + self.propFile
            if self.directory is None:
                cmd = cmd + " ."
            else:
                cmd = cmd + " " + self.directory
            if os.system(cmd):
                exit(1)
            else:
                f = self.openFile("CFG_PROPERTY", "r")
                lines = f.readlines()
                f.close()
                i = 0
                for prop in lines:
                    p = prop.replace("\n", "")
                    if i == 0:
                        self.propType = p
                    else:
                        self.propositions.append(prop)
                    i = i + 1
                if self.directory is None:
                    os.remove("CFG_PROPERTY")
                else:
                    os.remove(self.directory + os.sep + "CFG_PROPERTY")

    def outputModelOptions(self):
        opts = []
        opts.append("--capacity=" + str(self.capacity))
        if self.runTimeChecks:
            opts.append("--run-time-checks=1")
        else:
            opts.append("--run-time-checks=0")
        for prop in self.propositions:
            opts.append("--proposition=" + prop)
        for sym in self.symbols:
            opts.append("--define=" + sym)
        for param in self.parameters:
            opts.append("--parameter=" + param)
        f = open("model-options", "w")
        for o in opts:
            f.write(" " + o)
        f.close()

if __name__ == "__main__":
    C = Config()
    C.parseFromCommandLine()
    C.generatePropertyCode()
    C.correct()
    C.generateConfigFile()
    C.outputModelOptions()

exit(0)
