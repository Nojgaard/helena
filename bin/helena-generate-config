#!/usr/bin/python
#
#  File: helena-generate-config
#
#  Parse arguments from the command line and generate the appropriate
#  C configuration file.
#

import datetime
from datetime import date
from datetime import datetime
from datetime import time
import os
import re
import socket
import sys
import xml.dom.minidom

VERSION = "2.3"
DATE    = "April 1, 2013"

#  actions
EXPLORE     = "EXPLORE"
SIMULATE    = "SIMULATE"
BUILD_GRAPH = "BUILD-GRAPH"
CHECK       = "CHECK"

#  search algorithms
BFS         = "BFS"
DFS         = "DFS"
DBFS        = "DBFS"
DDFS        = "DDFS"
FRONTIER    = "FRONTIER"
RWALK       = "RWALK"
DELTA_DDD   = "DELTA-DDD"

#  trace types
FULL        = "FULL"
EVENTS      = "EVENTS"
STATE       = "STATE"

#  property types
LTL         = "LTL"
STATE       = "STATE"
DEADLOCK    = "DEADLOCK"

def exitWithError(err):
    print >> sys.stderr, "error: " + err
    exit(1)

def parseArgument(arg):
    S = re.search
    if S("^-(-)?[a-zA-Z\-]+(=.+)?$", arg):
        l = arg.split("=", 1)
        if len(l) == 2:
            return (l[0], l[1])
        else:
            return (l[0], None)
    else:
        return (None, None)

def parseIntArgument(val, shortForm, longForm):
    S = re.search
    if S("^-" + shortForm + "=", val) or S("^--" + longForm + "=", val):
        l = val.split("=")
        if len(l) <> 2:
            return None
        else:
            try:
                result = int(l[1])
                return result
            except ValueError:
                return None

def parseCheckArgument(val):
    S = re.search
    if not(S("^CHECK-", val.upper())):
        return (False, None)
    else:
        l = val.split("-")
        if len(l) <> 2:
            return (False, None)
        else:
            return (True, l[1])

def printVersion():
    print "helena " + VERSION + " --- " + DATE

def printHelp():
    print "usage: helena [option] ... [option] my-net.lna"
    print ""
    print "General options"
    print "  -h   --help"
    print "  -V   --version"
    print "  -v   --verbose"
    print "  -g   --progress={no-compile|no-check|no-report}"
    print "  -N   --action={EXPLORE|SIMULATE|BUILD-GRAPH|CHECK-prop}"
    print "  -p   --property-file=FILE"
    print "  -md  --model-directory=DIRECTORY"
    print ""
    print "Search and storage options"
    print "  -A   --algo={BFS|DFS|FRONTIER|DELTA-DDD|RWALK}"
    #print "  -A   --algo={BFS|DBFS|DFS|DDFS|FRONTIER|DELTA-DDD|RWALK}"
    print "  -t   --hash-size=H"
    print "  -W   --workers=WORKERS"
    print "  -cs  --candidate-set-size=N"
    #print "  -dc  --ddfs-comm-strategy={K<N>|M|D<N>} ... {K<N>|M|D<N>}"
    #print "  -mf  --machine-file=FILE"
    print ""
    print "Reduction techniques"
    print "  -H   --hash-compaction"
    print "  -P   --partial-order[={0|1}]"
    print "  -S   --state-caching[={0|1}]"
    print ""
    print "Search limits"
    print "  -ml  --memory-limit=N"
    print "  -tl  --time-limit=N"
    print "  -sl  --state-limit=N"
    print ""
    print "Model options"
    print "  -d   --define=SYMBOL-NAME"
    print "  -a   --capacity=N"
    print "  -r   --run-time-checks[={0|1}]"
    print "  -L   --link=OBJECT-FILE"
    print "  -m   --parameter=p=i"
    print ""
    print "Output"
    print "  -o   --report-file=FILE-NAME"
    print "  -tr  --trace-type={FULL|EVENTS|STATE}"

class Config:        

    def __init__(self):
        self.verbose = False
        self.version = False
        self.partialOrder = False
        self.stateCaching = False
        self.hashCompaction = False
        self.edgeLean = True
        self.workers = 1
        self.capacity = 1
        self.candidateSetSize = 100000
        self.memoryLimit = 0
        self.timeLimit = 0
        self.stateLimit = 0
        self.hashSize = 22
        self.algo = DFS
        self.traceType = FULL
        self.directory = None
        self.symbols = []
        self.action = EXPLORE
        self.runTimeChecks = True
        self.inFile = None
        self.inFileExt = None
        self.prop = None
        self.propFile = None
        self.propType = None
        self.propositions = []
        self.parameters = []
        self.ddfsCommStrat = []
        self.bfsQueueBlockSize = 10000
        self.dfsStackBlockSize = 10000
        self.rwalkMaxDepth = 1000
        self.shmemHeapSize = 1000000
        self.stateCachingGcThreshold = 50
        self.stateCachingGcRatio = 0.01

    #  correct inconsistencies in received arguments
    def correct(self):
        if self.action == BUILD_GRAPH:
            self.algo = DELTA_DDD
            self.prop = None
            self.stateCaching = False
            self.hashCompaction = False
            self.partialOrder = False
            self.workers = 1
        elif self.action == CHECK and self.propType == LTL:
            self.algo = DFS
            if self.traceType == STATE:
                self.traceType = FULL
        elif self.action == SIMULATE:
            self.runTimeChecks = True
        if self.algo == RWALK:
            self.stateCaching = False
            self.hashCompaction = False
            self.partialOrder = False
        elif self.algo == FRONTIER:
            self.stateCaching = False
            self.traceType = STATE
        elif self.algo == DELTA_DDD:
            self.stateCaching = False
            self.hashCompaction = False
            self.partialOrder = False
        elif self.algo == BFS:
            self.stateCaching = False
        elif self.algo == DDFS:
            self.partialOrder = False
            self.stateCaching = False
        elif self.algo == DBFS:
            self.partialOrder = False
            self.stateCaching = False
            self.traceType = STATE

    def openFile(self, name, mode):
        if self.directory is None:
            return open(name, mode)
        else:
            return open(self.directory + os.sep + name, mode)

    def generateConfigFile(self):
        f = self.openFile("config.h", "w")
        W = f.write
        now = datetime.now()
        W("#ifndef LIB_CONFIG\n")
        W("#define LIB_CONFIG\n")
        W("\n")
        W("#define CFG_MODEL_CONFIG\n")
        W("#define CFG_REPORT_FILE \"report.xml\"\n")
        W("#define CFG_RG_REPORT_FILE \"rg-report.xml\"\n")
        W("#define CFG_GRAPH_FILE \"graph.dat\"\n")
        W("#define CFG_WITH_OBSERVER\n")
        W("#define CFG_DATE \"" + \
          now.strftime("%B, %d, %Y at %H:%M:%S") + "\"\n")
        W("#define CFG_FILE_PATH \"" + os.path.realpath(self.inFile) + "\"\n")
        if self.inFileExt == ".lna":
            W("#define CFG_LANGUAGE \"helena\"\n")
            W("#define CFG_LANGUAGE_LNA\n")
            W("#define CFG_EVENT_UNDOABLE\n")
            W("#define CFG_MODEL_HAS_GRAPH_ROUTINES\n")
        elif self.inFileExt == ".dve":
            (model, _) = os.path.splitext(os.path.basename(self.inFile))
            if model == "": model = "model"
            W("#define CFG_MODEL_NAME \"" + model + "\"\n")
            W("#define CFG_LANGUAGE \"dve\"\n")
            W("#define CFG_LANGUAGE_DVE\n")

        #  search algorithm and storage type
        W("#define CFG_ALGO_" + self.algo.replace("-", "_") + "\n")
        if self.algo == FRONTIER:
            W("#define CFG_HASH_STORAGE\n")
        elif self.algo == BFS:
            W("#define CFG_HASH_STORAGE\n")
        elif self.algo == DFS:
            W("#define CFG_HASH_STORAGE\n")
        elif self.algo == DBFS:
            W("#define CFG_HASH_STORAGE\n")
        elif self.algo == DDFS:
            W("#define CFG_HASH_STORAGE\n")
            if len(self.ddfsCommStrat) > 0:
                W("#define CFG_DDFS_COMM_STRAT\n")                
            K = False
            D = False
            M = False
            for (strat, val) in self.ddfsCommStrat:
                if strat == "K" and not K:
                    W("#define CFG_DDFS_COMM_STRAT_K " + str(val) + "\n")
                    K = True
                elif strat == "D" and not D:
                    W("#define CFG_DDFS_COMM_STRAT_DEGREE " + str(val) + "\n")
                    D = True
                elif strat == "M" and not M:
                    W("#define CFG_DDFS_COMM_STRAT_MINE\n")
                    M = True
        elif self.algo == DELTA_DDD:
            W("#define CFG_DELTA_DDD_STORAGE\n")
        elif self.algo == RWALK:
            pass

        #  state caching
        if self.stateCaching:
            W("#define CFG_STATE_CACHING\n")

        #  search limits
        if self.memoryLimit != 0:
            W("#define CFG_MEMORY_LIMITED\n")
            W("#define CFG_MAX_MEMORY " + str(self.memoryLimit) + "\n")
        if self.timeLimit != 0:
            W("#define CFG_TIME_LIMITED\n")
            W("#define CFG_MAX_TIME " + str(self.timeLimit) + "\n")
        if self.stateLimit != 0:
            W("#define CFG_STATE_LIMITED\n")
            W("#define CFG_MAX_STATE " + str(self.stateLimit) + "\n")

        #  hash compaction
        if self.hashCompaction:
            W("#define CFG_HASH_COMPACTION\n")

        #  action to perform
        W("#define CFG_ACTION_" + self.action.replace("-", "_") + "\n")
        if self.action == CHECK:
            W("#define CFG_PROPERTY \"" + self.prop + "\"\n")
            if self.propType == LTL:
                W("#define CFG_ACTION_CHECK_LTL\n")
            elif self.propType == STATE:
                W("#define CFG_ACTION_CHECK_SAFETY\n")
            elif self.propType == DEADLOCK:
                W("#define CFG_ACTION_CHECK_SAFETY\n")

        #  trace mode
        W("#define CFG_TRACE_" + self.traceType + "\n")

        #  partial order reduction
        if self.partialOrder:
            W("#define CFG_POR\n")
            if self.propType is not None and \
               self.propType != DEADLOCK:
                W("#define CFG_PROVISO\n")
        if self.edgeLean:
            W("#define CFG_EDGE_LEAN\n")
                
        #  parallel mode
        if self.workers > 1:
            W("#define CFG_PARALLEL\n")

        #  distributed mode
        if self.algo in [ DBFS, DDFS ]:
            W("#define CFG_DISTRIBUTED\n")

        #  other parameters
        params = [
            ("BFS_QUEUE_BLOCK_SIZE ", self.bfsQueueBlockSize),
            ("DELTA_DDD_CAND_SET_SIZE ", self.candidateSetSize),
            ("DFS_STACK_BLOCK_SIZE ", self.dfsStackBlockSize),
            ("HASH_SIZE ", pow(2, self.hashSize)),
            ("HASH_SIZE_BITS ", self.hashSize),
            ("HASH_SIZE_M ", pow(2, self.hashSize) - 1),
            ("NO_WORKERS ", self.workers),
            ("RWALK_MAX_DEPTH ", self.rwalkMaxDepth),
            ("STATE_CACHING_GC_THRESHOLD ", self.stateCachingGcThreshold),
            ("STATE_CACHING_GC_RATIO ", self.stateCachingGcRatio),
            ("SYM_HEAP_SIZE ", self.shmemHeapSize)
        ]
        for (p, v) in params:
            W("#define CFG_" + p + " " + str(v) + "\n")

        W("\n#endif  /*  LIB_CONFIG  */\n")
        f.close()

    def handleNumericalOption(self, attr, val):
        try:
            if val is None:
                return False
            i = int(val)
            setattr(self, attr, i)
            return True
        except ValueError:
            return False

    def handleStringOption(self, attr, val):
        if val is None:
            return False
        else:
            if attr is not None:
                setattr(self, attr, val)
            return True

    def handleEnumOption(self, attr, val, okVal):
        if val is None:
            return False
        if val.upper() in okVal:
            if attr is not None:
                setattr(self, attr, val.upper())
            return True
        else:
            return False
        
    def parseFromCommandLine(self):
        S = re.search
        for arg in sys.argv[1 : len(sys.argv) - 2]:
            recognized = True
            (opt, val) = parseArgument(arg)

            #  options with no value
            if (opt, val) in [("-v", None),("--verbose", None) ]:
                self.verbose = True
            elif(opt, val) in [("-V", None),("--version", None) ]:
                printVersion()
                exit(0)
            elif(opt, val) in [("-h", None),("--help", None) ]:
                printHelp()
                exit(0)
                
            #  boolean options
            elif opt in [ "-P", "--partial-order" ]:
                self.partialOrder = (val is None) or val == "1"
            elif opt in [ "-r", "--run-time-checks" ]:
                self.runTimeChecks = (val is None) or val == "1"
            elif opt in [ "-S", "--state-caching" ]:
                self.stateCaching = (val is None) or val == "1"
            elif opt in [ "-H", "--hash-compaction" ]:
                self.hashCompaction = (val is None) or val == "1"

            #  numerical options
            elif opt in [ "-W", "--workers" ]:
                recognized = self.handleNumericalOption("workers", val)
            elif opt in [ "-a", "--capacity" ]:
                recognized = self.handleNumericalOption("capacity", val)
            elif opt in [ "-cs", "--candidate-set-size" ]:
                recognized = self.handleNumericalOption("candidateSetSize",
                                                        val)
            elif opt in [ "-t", "--hash-size" ]:
                recognized = self.handleNumericalOption("hashSize", val)
                if self.hashSize > 32:
                    self.hashSize = 32
            elif opt in [ "-ml", "--memory-limit" ]:
                recognized = self.handleNumericalOption("memoryLimit", val)
            elif opt in [ "-tl", "--time-limit" ]:
                recognized = self.handleNumericalOption("timeLimit", val)
            elif opt in [ "-sl", "--state-limit" ]:
                recognized = self.handleNumericalOption("stateLimit", val)

            #  string options
            elif opt in [ "-d", "--define" ]:
                recognized = self.handleStringOption(None, val)
                if recognized:
                    self.symbols.append(val)
            elif opt in [ "-L", "--link" ]:
                recognized = self.handleStringOption("link", val)
            elif opt in [ "-p", "--property-file" ]:
                recognized = self.handleStringOption("propertyFile", val)
            elif opt in [ "-o", "--report-file" ]:
                recognized = self.handleStringOption("reportFile", val)
            elif opt in [ "-m", "--parameter" ]:
                recognized = self.handleStringOption(None, val)
                if recognized:
                    l = val.split("=")
                    recognized = len(l) == 2
                    if recognized:
                        self.parameters.append(val)

            #  enum options
            elif opt in [ "-A", "--algo" ]:
                recognized = self.handleEnumOption \
                             ("algo", val, [BFS, DBFS, DFS, DDFS, FRONTIER, \
                                            DELTA_DDD, RWALK])
            elif opt in [ "-tr", "--trace-type" ]:
                recognized = self.handleEnumOption \
                             ("traceType", val, [FULL, EVENTS, STATE])
            elif opt in [ "-N", "--action" ]:
                self.prop = None
                recognized = self.handleEnumOption \
                             ("action", val, [SIMULATE, EXPLORE, BUILD_GRAPH])
                if not recognized:
                    (recognized, p) = parseCheckArgument(val)
                    if recognized:
                        self.action = CHECK
                        self.prop = p

            #  special case options
            elif opt in [ "-dc", "--ddfs-comm-strategy" ]:
                for s in val.split(","):
                    recognized = True
                    if S("^K[0-9]*", s):
                        self.ddfsCommStrat.append(("K", int(s[1:])))
                    elif S("^D[0-9]*", s):
                        self.ddfsCommStrat.append(("D", int(s[1:])))
                    elif s == "M":
                        self.ddfsCommStrat.append(("M", None))
                    else:
                        recognized = False

            #  option that are handled directly by the helena script
            elif opt in [ "-md", "--model-directory" ]:
                recognized = True
            elif opt in [ "-mf", "--machine-file" ]:
                recognized = True
            elif opt in [ "-g", "--progress" ]:
                recognized = True

            #  does not match any option
            else:
                recognized = False
                val = None

            if not recognized:
                if val is not None:
                    err = "invalid value for option " + opt + ": " + val
                else:
                    err = "invalid option: " + arg
                exitWithError(err)
        if len(sys.argv) >= 2:
            self.inFile = sys.argv[len(sys.argv) - 2]
            (f, self.inFileExt) = os.path.splitext(self.inFile)
            if self.propFile is None:
                self.propFile = f + ".prop" + self.inFileExt
        if len(sys.argv) >= 3:
            self.directory = sys.argv[len(sys.argv) - 1]

    def generatePropertyCode(self):
        if self.action != CHECK \
           or self.prop is None \
           or self.propFile is None:
            f = self.openFile("prop.h", "w")
            f.close()
            f = self.openFile("prop.c", "w")
            f.close()
        else:
            cmd = "helena-generate-property "
            cmd = cmd + " " + self.prop + " " + self.propFile
            if self.directory is None:
                cmd = cmd + " ."
            else:
                cmd = cmd + " " + self.directory
            if os.system(cmd):
                exit(1)
            else:
                f = self.openFile("CFG_PROPERTY", "r")
                lines = f.readlines()
                f.close()
                i = 0
                for prop in lines:
                    p = prop.replace("\n", "")
                    if i == 0:
                        self.propType = p
                    else:
                        self.propositions.append(prop)
                    i = i + 1
                if self.directory is None:
                    os.remove("CFG_PROPERTY")
                else:
                    os.remove(self.directory + os.sep + "CFG_PROPERTY")

    def outputModelOptions(self):
        opts = []
        opts.append("--capacity=" + str(self.capacity))
        if self.runTimeChecks:
            opts.append("--run-time-checks=1")
        else:
            opts.append("--run-time-checks=0")
        for prop in self.propositions:
            opts.append("--proposition=" + prop)
        for sym in self.symbols:
            opts.append("--define=" + sym)
        for param in self.parameters:
            opts.append("--parameter=" + param)
        f = open("model-options", "w")
        for o in opts:
            f.write(" " + o)
        f.close()

if __name__ == "__main__":
    C = Config()
    C.parseFromCommandLine()
    C.generatePropertyCode()
    C.correct()
    C.generateConfigFile()
    C.outputModelOptions()

exit(0)
