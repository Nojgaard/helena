#!/usr/bin/python
#
#  File: helena-generate-config
#
#  Parse arguments from the command line and generate the appropriate
#  C configuration file.
#

import datetime
from datetime import date
from datetime import datetime
from datetime import time
import os
import re
import socket
import sys
import xml.dom.minidom

VERSION = "2.3"
DATE    = "April 1, 2013"

#  actions
EXPLORE     = "EXPLORE"
SIMULATE    = "SIMULATE"
BUILD_GRAPH = "BUILD-GRAPH"
CHECK       = "CHECK"

#  search algorithms
BFS         = "BFS"
DFS         = "DFS"
DBFS        = "DBFS"
DDFS        = "DDFS"
FRONTIER    = "FRONTIER"
RWALK       = "RWALK"
DELTA_DDD   = "DELTA-DDD"

#  trace types
FULL        = "FULL"
EVENTS      = "EVENTS"
STATE       = "STATE"

#  property types
LTL         = "LTL"
STATE       = "STATE"
DEADLOCK    = "DEADLOCK"

def exitWithError(err):
    print >> sys.stderr, "error: " + err
    exit(1)

def parseArgument(arg):
    S = re.search
    if S("^-(-)?[a-zA-Z\-]+(=.+)?$", arg):
        l = arg.split("=", 1)
        if len(l) == 2:
            return (l[0], l[1])
        else:
            return (l[0], None)
    else:
        return (None, None)

def parseIntArgument(val, shortForm, longForm):
    S = re.search
    if S("^-" + shortForm + "=", val) or S("^--" + longForm + "=", val):
        l = val.split("=")
        if len(l) <> 2:
            return None
        else:
            try:
                result = int(l[1])
                return result
            except ValueError:
                return None

def parseCheckArgument(val):
    S = re.search
    if not(S("^CHECK-", val.upper())):
        return (False, None)
    else:
        l = val.split("-")
        if len(l) <> 2:
            return (False, None)
        else:
            return (True, l[1])

def printVersion():
    print "helena " + VERSION + " --- " + DATE

def printHelp():
    print "usage: helena [option] ... [option] my-net.lna"
    print ""
    print "General options"
    print "  -h   --help"
    print "  -V   --version"
    print "  -v   --verbose"
    print "  -N   --action={EXPLORE|SIMULATE|BUILD-GRAPH|CHECK-prop}"
    print "  -g   --progress={no-compile|no-check|no-report}"
    print "  -b   --observer[={0|1}]"
    print "  -p   --property-file=FILE"
    print "  -md  --model-directory=DIRECTORY"
    print "  -wp  --with-papi[={0|1}]"
    print ""
    print "Search and storage options"
    print "  -A   --algo={BFS|DFS|FRONTIER|DELTA-DDD|RWALK}"
    #print "  -A   --algo={BFS|DBFS|DFS|DDFS|FRONTIER|DELTA-DDD|RWALK}"
    print "  -t   --hash-size=N"
    print "  -W   --workers=N"
    print "  -C   --comm-workers=N"
    print "  -cs  --candidate-set-size=N"
    print "  -hs  --shmem-heap-size=N"
    #print "  -mf  --machine-file=FILE"
    print ""
    print "Reduction techniques"
    print "  -H   --hash-compaction[={0|1}]"
    print "  -P   --partial-order[={0|1}]"
    print "  -E   --edge-lean[={0|1}]"
    print "  -S   --state-caching[={0|1}]"
    print ""
    print "Search limits"
    print "  -ml  --memory-limit=N"
    print "  -tl  --time-limit=N"
    print "  -sl  --state-limit=N"
    print ""
    print "Model options"
    print "  -d   --define=SYMBOL-NAME"
    print "  -a   --capacity=N"
    print "  -r   --run-time-checks[={0|1}]"
    print "  -L   --link=OBJECT-FILE"
    print "  -m   --parameter=p=N"
    print ""
    print "Output"
    print "  -o   --report-file=FILE-NAME"
    print "  -tr  --trace-type={FULL|EVENTS|STATE}"

class Config:        

    def __init__(self):
        self.verbose = False
        self.version = False
        self.partialOrder = False
        self.stateCaching = False
        self.hashCompaction = False
        self.edgeLean = False
        self.withPapi = False
        self.withObserver = True
        self.workers = 1
        self.commWorkers = 1
        self.capacity = 1
        self.memoryLimit = 0
        self.timeLimit = 0
        self.stateLimit = 0
        self.algo = DFS
        self.traceType = FULL
        self.directory = None
        self.symbols = []
        self.action = EXPLORE
        self.runTimeChecks = True
        self.inFile = None
        self.inFileExt = None
        self.prop = None
        self.propFile = None
        self.propType = None
        self.propositions = []
        self.parameters = []
        self.ddfsCommStrat = []
        self.hashSize = 22
        self.bfsQueueBlockSize = 10 ** 4
        self.dfsStackBlockSize = 10 ** 4
        self.rwalkMaxDepth = 10 ** 3
        self.shmemHeapSize = 10 ** 6
        self.candidateSetSize = 10 ** 5
        self.stateCachingGcThreshold = 50
        self.stateCachingGcRatio = 0.01

    #  correct inconsistencies in received arguments
    def correct(self):
        if self.action == BUILD_GRAPH:
            self.algo = DELTA_DDD
            self.prop = ""
            self.stateCaching = False
            self.hashCompaction = False
            self.partialOrder = False
            self.workers = 1
        elif self.action == CHECK and self.propType == LTL:
            self.algo = DFS
            if self.traceType == STATE:
                self.traceType = FULL
        elif self.action == SIMULATE:
            self.runTimeChecks = True
        if self.algo == BFS:
            self.stateCaching = False
        elif self.algo == FRONTIER:
            self.stateCaching = False
            self.traceType = STATE
        elif self.algo == RWALK:
            self.stateCaching = False
            self.hashCompaction = False
            self.partialOrder = False
            self.edgeLean = False
        elif self.algo == DELTA_DDD:
            self.stateCaching = False
            self.hashCompaction = False
            self.partialOrder = False
            self.edgeLean = False
        elif self.algo == DDFS:
            self.partialOrder = False
            self.stateCaching = False
            self.edgeLean = False
        elif self.algo == DBFS:
            self.partialOrder = False
            self.stateCaching = False
            self.edgeLean = False
            self.traceType = STATE

    def openFile(self, name, mode):
        if self.directory is None:
            return open(name, mode)
        else:
            return open(self.directory + os.sep + name, mode)

    def generateConfigFile(self):
        
        f = self.openFile("config.h", "w")
        W = f.write
        
        W("#ifndef LIB_CONFIG\n")
        W("#define LIB_CONFIG\n")
        W("\n")
        
        now = datetime.now()
        model = ""
        language = self.inFileExt[1:]
        if language == "dve":
            (model, _) = os.path.splitext(os.path.basename(self.inFile))
            if model == "":
                model = "model"
        prop = self.prop
        if prop is None:
            prop = ""
            
        params = [
            ("ACTION_BUILD_GRAPH", self.action == BUILD_GRAPH),
            ("ACTION_CHECK_LTL", self.action == CHECK and self.propType == LTL),
            ("ACTION_CHECK_SAFETY", self.action == CHECK and
             self.propType in [ STATE, DEADLOCK]),
            ("ACTION_CHECK", self.action == CHECK),
            ("ACTION_EXPLORE", self.action == EXPLORE),
            ("ACTION_SIMULATE", self.action == SIMULATE),
            ("ALGO_BFS", self.algo == BFS),
            ("ALGO_DBFS", self.algo == DBFS),
            ("ALGO_DDFS", self.algo == DDFS),
            ("ALGO_DELTA_DDD", self.algo == DELTA_DDD),
            ("ALGO_DFS", self.algo == DFS),
            ("ALGO_FRONTIER", self.algo == FRONTIER),
            ("ALGO_RWALK", self.algo == RWALK),
            ("BFS_QUEUE_BLOCK_SIZE", self.bfsQueueBlockSize),
            ("DATE", "\"" + now.strftime("%B, %d, %Y at %H:%M:%S") + "\""),
            ("DELTA_DDD_CAND_SET_SIZE", self.candidateSetSize),
            ("DELTA_DDD_STORAGE", self.algo == DELTA_DDD),
            ("DFS_STACK_BLOCK_SIZE", self.dfsStackBlockSize),
            ("DISTRIBUTED", self.algo in [ DBFS, DDFS ]),
            ("EDGE_LEAN", self.edgeLean),
            ("EVENT_UNDOABLE", self.inFileExt == ".lna"),
            ("FILE_PATH", "\"" + os.path.realpath(self.inFile) + "\""),
            ("GRAPH_FILE", "\"graph.dat\""),
            ("HASH_COMPACTION", self.hashCompaction),
            ("HASH_SIZE_BITS", self.hashSize),
            ("HASH_SIZE_M", pow(2, self.hashSize) - 1),
            ("HASH_SIZE", pow(2, self.hashSize)),
            ("HASH_STORAGE", self.algo not in [ DELTA_DDD, RWALK ]),
            ("LANGUAGE", "\"" + language + "\""),
            ("LANGUAGE_DVE", self.inFileExt == ".dve"),
            ("LANGUAGE_LNA", self.inFileExt == ".lna"),
            ("MAX_MEMORY", self.memoryLimit),
            ("MAX_STATE", self.stateLimit),
            ("MAX_TIME", self.timeLimit),
            ("MEMORY_LIMITED", self.memoryLimit != 0),
            ("MODEL_HAS_GRAPH_ROUTINES", self.inFileExt == ".lna"),
            ("MODEL_NAME", "\"" + model + "\""),
            ("NO_COMM_WORKERS", self.commWorkers),
            ("NO_WORKERS", self.workers),
            ("PARALLEL", self.workers > 1),
            ("POR", self.partialOrder),
            ("PROPERTY", "\"" + prop + "\""),
            ("PROVISO", self.partialOrder and self.propType is not None and
             self.propType != DEADLOCK),
            ("REPORT_FILE", "\"report.xml\""),
            ("RG_REPORT_FILE", "\"rg-report.xml\""),
            ("RWALK_MAX_DEPTH", self.rwalkMaxDepth),
            ("SHMEM_HEAP_SIZE", self.shmemHeapSize),
            ("STATE_CACHING_GC_RATIO", self.stateCachingGcRatio),
            ("STATE_CACHING_GC_THRESHOLD", self.stateCachingGcThreshold),
            ("STATE_CACHING", self.stateCaching),
            ("STATE_LIMITED", self.stateLimit != 0),
            ("TIME_LIMITED", self.timeLimit != 0),
            ("TRACE_EVENTS", self.traceType == EVENTS),
            ("TRACE_FULL", self.traceType == FULL),
            ("TRACE_STATE", self.traceType == STATE),
            ("WITH_OBSERVER", self.withObserver),
            ("WITH_PAPI", self.withPapi)
        ]
        
        for (p, v) in params:
            if type(v) == bool:
                W("#define CFG_" + p + " " + ("1" if v else "0") + "\n")
            elif type(v) in [ float, int ]:
                W("#define CFG_" + p + " " + str(v) + "\n")
            elif type(v) == str:
                W("#define CFG_" + p + " " + v + "\n")
            else:
                raise Exception
        W("\n#endif  /*  LIB_CONFIG  */\n")
        f.close()

    def handleNumericalOption(self, attr, val):
        try:
            if val is None:
                return False
            i = int(val)
            setattr(self, attr, i)
            return True
        except ValueError:
            return False

    def handleStringOption(self, attr, val):
        if val is None:
            return False
        else:
            if attr is not None:
                setattr(self, attr, val)
            return True

    def handleEnumOption(self, attr, val, okVal):
        if val is None:
            return False
        if val.upper() in okVal:
            if attr is not None:
                setattr(self, attr, val.upper())
            return True
        else:
            return False
        
    def parseFromCommandLine(self):
        S = re.search
        for arg in sys.argv[1 : len(sys.argv) - 2]:
            recognized = True
            (opt, val) = parseArgument(arg)

            #  options with no value
            if (opt, val) in [("-v", None),("--verbose", None) ]:
                self.verbose = True
            elif(opt, val) in [("-V", None),("--version", None) ]:
                printVersion()
                exit(0)
            elif(opt, val) in [("-h", None),("--help", None) ]:
                printHelp()
                exit(0)
                
            #  boolean options
            elif opt in [ "-b", "--observer" ]:
                self.withObserver = (val is None) or val == "1"
            elif opt in [ "-P", "--partial-order" ]:
                self.partialOrder = (val is None) or val == "1"
            elif opt in [ "-E", "--edge-lean" ]:
                self.edgeLean = (val is None) or val == "1"
            elif opt in [ "-r", "--run-time-checks" ]:
                self.runTimeChecks = (val is None) or val == "1"
            elif opt in [ "-S", "--state-caching" ]:
                self.stateCaching = (val is None) or val == "1"
            elif opt in [ "-H", "--hash-compaction" ]:
                self.hashCompaction = (val is None) or val == "1"
            elif opt in [ "-wp", "--with-papi" ]:
                self.withPapi = (val is None) or val == "1"

            #  numerical options
            elif opt in [ "-W", "--workers" ]:
                recognized = self.handleNumericalOption("workers", val)
            elif opt in [ "-C", "--comm-workers" ]:
                recognized = self.handleNumericalOption("commWorkers", val)
            elif opt in [ "-a", "--capacity" ]:
                recognized = self.handleNumericalOption("capacity", val)
            elif opt in [ "-cs", "--candidate-set-size" ]:
                recognized = self.handleNumericalOption("candidateSetSize",
                                                        val)
            elif opt in [ "-hs", "--shmem-heap-size" ]:
                recognized = self.handleNumericalOption("shmemHeapSize", val)
            elif opt in [ "-t", "--hash-size" ]:
                recognized = self.handleNumericalOption("hashSize", val)
                if self.hashSize > 32:
                    self.hashSize = 32
            elif opt in [ "-ml", "--memory-limit" ]:
                recognized = self.handleNumericalOption("memoryLimit", val)
            elif opt in [ "-tl", "--time-limit" ]:
                recognized = self.handleNumericalOption("timeLimit", val)
            elif opt in [ "-sl", "--state-limit" ]:
                recognized = self.handleNumericalOption("stateLimit", val)

            #  string options
            elif opt in [ "-d", "--define" ]:
                recognized = self.handleStringOption(None, val)
                if recognized:
                    self.symbols.append(val)
            elif opt in [ "-L", "--link" ]:
                recognized = self.handleStringOption("link", val)
            elif opt in [ "-p", "--property-file" ]:
                recognized = self.handleStringOption("propertyFile", val)
            elif opt in [ "-o", "--report-file" ]:
                recognized = self.handleStringOption("reportFile", val)
            elif opt in [ "-m", "--parameter" ]:
                recognized = self.handleStringOption(None, val)
                if recognized:
                    l = val.split("=")
                    recognized = len(l) == 2
                    if recognized:
                        self.parameters.append(val)

            #  enum options
            elif opt in [ "-A", "--algo" ]:
                recognized = self.handleEnumOption \
                             ("algo", val, [BFS, DBFS, DFS, DDFS, FRONTIER, \
                                            DELTA_DDD, RWALK])
            elif opt in [ "-tr", "--trace-type" ]:
                recognized = self.handleEnumOption \
                             ("traceType", val, [FULL, EVENTS, STATE])
            elif opt in [ "-N", "--action" ]:
                self.prop = None
                recognized = self.handleEnumOption \
                             ("action", val, [SIMULATE, EXPLORE, BUILD_GRAPH])
                if not recognized:
                    (recognized, p) = parseCheckArgument(val)
                    if recognized:
                        self.action = CHECK
                        self.prop = p

            #  special case options
            elif opt in [ "-dc", "--ddfs-comm-strategy" ]:
                for s in val.split(","):
                    recognized = True
                    if S("^K[0-9]*", s):
                        self.ddfsCommStrat.append(("K", int(s[1:])))
                    elif S("^D[0-9]*", s):
                        self.ddfsCommStrat.append(("D", int(s[1:])))
                    elif s == "M":
                        self.ddfsCommStrat.append(("M", None))
                    else:
                        recognized = False

            #  option that are handled directly by the helena script
            elif opt in [ "-md", "--model-directory" ]:
                recognized = True
            elif opt in [ "-mf", "--machine-file" ]:
                recognized = True
            elif opt in [ "-g", "--progress" ]:
                recognized = True

            #  does not match any option
            else:
                recognized = False
                val = None

            if not recognized:
                if val is not None:
                    err = "invalid value for option " + opt + ": " + val
                else:
                    err = "invalid option: " + arg
                exitWithError(err)
        if len(sys.argv) >= 2:
            self.inFile = sys.argv[len(sys.argv) - 2]
            (f, self.inFileExt) = os.path.splitext(self.inFile)
            if self.propFile is None:
                self.propFile = f + ".prop" + self.inFileExt
        if len(sys.argv) >= 3:
            self.directory = sys.argv[len(sys.argv) - 1]

    def generatePropertyCode(self):
        if self.action != CHECK \
           or self.prop is None \
           or self.propFile is None:
            f = self.openFile("prop.h", "w")
            f.close()
            f = self.openFile("prop.c", "w")
            f.close()
        else:
            cmd = "helena-generate-property "
            cmd = cmd + " " + self.prop + " " + self.propFile
            if self.directory is None:
                cmd = cmd + " ."
            else:
                cmd = cmd + " " + self.directory
            if os.system(cmd):
                exit(1)
            else:
                f = self.openFile("CFG_PROPERTY", "r")
                lines = f.readlines()
                f.close()
                i = 0
                for prop in lines:
                    p = prop.replace("\n", "")
                    if i == 0:
                        self.propType = p
                    else:
                        self.propositions.append(prop)
                    i = i + 1
                if self.directory is None:
                    os.remove("CFG_PROPERTY")
                else:
                    os.remove(self.directory + os.sep + "CFG_PROPERTY")

    def outputModelOptions(self):
        opts = []
        opts.append("--capacity=" + str(self.capacity))
        if self.runTimeChecks:
            opts.append("--run-time-checks=1")
        else:
            opts.append("--run-time-checks=0")
        for prop in self.propositions:
            opts.append("--proposition=" + prop)
        for sym in self.symbols:
            opts.append("--define=" + sym)
        for param in self.parameters:
            opts.append("--parameter=" + param)
        f = open("model-options", "w")
        for o in opts:
            f.write(" " + o)
        f.close()

if __name__ == "__main__":
    C = Config()
    C.parseFromCommandLine()
    C.generatePropertyCode()
    C.correct()
    C.generateConfigFile()
    C.outputModelOptions()

exit(0)
