#! /bin/bash
#
#  File: helena
#

gcc='/usr/bin/gcc -Wunused-result'
shcc='/usr/bin/oshcc -Wunused-result'
shrun='/usr/bin/oshrun'

helenaDir=$HOME/.helena
tmpDir=$HOME/.helena/tmp-$RANDOM

#  by default we compile the generated code with gcc
CC=$gcc

RUN="./helena-checker"

#  executable names
lnaGenerator=helena-generate
dveGenerator=helena-generate-dve
checkerGenerator=helena-generate-checker
configGenerator=helena-generate-config
propertyGenerator=helena-generate-property
vectorsGenerator=helena-generate-vectors
reporter=helena-report
reportsMerger=helena-merge-reports
preProc=helena-pp

xmlReportFile=report.xml
xmlReportTmpFile=report.xml.tmp
xmlGraphReportFile=rg-report.xml
graphFile=graph.dat
version=2.3
versionFile=VERSION

#  options to pass for basic compilation
CCopt="-pthread -lm"

commonFiles="vectors"
checkerSrcFiles="bfs bfs_queue buchi common config ddfs_comm dfs dfs_stack
event graph heap hash_array hash_compaction hash_tbl observer pd4 prop
random_walk report state simulator storage vectors"

exitWithError () {
    rm -rf $tmpDir &> /dev/null
    exit 1
}

error () {
    echo "error: "$* > /dev/stderr
    exitWithError
}

msg () {
    [ $verbose -eq 1 ] && echo $*
}

getModelDir () {
    if [ z$modelDir != z ]
    then
	echo $modelDir
    elif [ z$language = z ]
    then
	error "\$language not set"
    elif [ z$model = z ]
    then
	error "\$model not set"
    else
	echo $helenaDir/models/$language/$model
    fi
}

checkExecutable () {
    ex=$1
    which $ex &> /dev/null
    if [ $? -ne 0 ]
    then
	msg="executable '"$ex"' could not be located"
	msg=$msg" in your PATH environment variable."
        error $msg
	exitWithError
    fi
}

createDirectory () {
    dir=$1
    [ -d $dir ] && return
    msg "create directory '"$dir"'"
    mkdir $dir &> /dev/null
    [ ! -d $dir ] && error "could not create directory '"$dir"'"
}

createEnvironment () {
    if [ -d $helenaDir -a -e $helenaDir/$versionFile ]
    then
	v=$(cat $helenaDir/$versionFile)
	if [ "$v" != "$version" ]
	then
	    echo "new version of Helena ($v -> $version)"
	    echo "-> reinitialisation of directory $helenaDir"
	    rm -rf $helenaDir &> /dev/null
	fi
    fi
    createDirectory $helenaDir
    createDirectory $helenaDir/common
    createDirectory $helenaDir/models
    createDirectory $helenaDir/models/lna
    createDirectory $helenaDir/models/dve
    echo $version > $helenaDir/$versionFile
}

compileCFiles () {
    local dir=$(getModelDir)/src
    pushd $dir &> /dev/null
    cp $helenaDir/common/* $(getModelDir)/src/ &> /dev/null
    links=$initLinks
    for f in $modelSrcFiles $checkerSrcFiles
    do
	[ ! -e $f.c ] && continue
	links=$links" "$f".o"
	if [ ! -e $f.o ]
	then
	    compileCmd="$CC -c $f.c"
	    msg "   > compile file "$f.c" ("$compileCmd")"
	    eval $compileCmd		
	    if [ ! $? -eq 0 ]
	    then
		error "compilation of file "$dir"/"$f".c failed"
	    fi
	fi
    done
    compileCmd="$CC $links -o helena-checker main.c"
    msg "   > compile file main.c ("$compileCmd")"
    eval $compileCmd
    if [ ! $? -eq 0 ]
    then
	error "compilation of file "$dir"/main.c failed"
    fi
    #  copy common files in the common directory
    for f in $commonFiles
    do
	if [ -e $f.c -a -e $f.h -a -e $f.o ]
	then
	    cp $f.c $f.h $f.o $helenaDir/common/
	fi
    done
    popd &> /dev/null
}

createMakefile () {
    local dir=$(getModelDir)/src
    pushd $dir &> /dev/null
    links=$initLinks
    makefile=makefile
    makefileGP=makefile.gp
    makefileVG=makefile.vg
    echo "all:" > $makefile
    echo "gnuprof:" > $makefileGP
    echo "valgrind:" > $makefileVG
    for f in $modelSrcFiles $checkerSrcFiles
    do
	if [ -e $f.c ]
	then
	    echo -e "\t$CC -c $f.c" >> $makefile
	    echo -e "\t$CC_GP -c $f.c" >> $makefileGP
	    echo -e "\t$CC_VG -c $f.c" >> $makefileVG
	    links=$links" "$f".o"
	fi
    done
    echo -e "\t$CC $links -o helena-checker main.c\n" >> $makefile
    echo -e "\t$CC_GP $links -o helena-checker main.c\n" >> $makefileGP
    echo -e "\t$CC_VG $links -o helena-checker main.c\n" >> $makefileVG
    (cat $makefile $makefileGP $makefileVG > $makefile.tmp ;
	mv $makefile.tmp $makefile ;
	rm $makefileGP $makefileVG) &> /dev/null
    (echo "report:" ;
	echo -e "\tmake gnuprof" ;
	echo -e "\t./helena-checker &> /dev/null" ;
	echo -e "\techo \"======================\" >> report.txt" ;
	echo -e "\techo \"==  GNUPROF REPORT  ==\" >> report.txt" ;
	echo -e "\techo \"======================\" >> report.txt" ;
	echo -e "\tgprof ./helena-checker >> report.txt" ;
	echo -e "\techo \"\" >> report.txt" ;
	echo -e "\techo \"\" >> report.txt" ;
	echo -e "\techo \"\" >> report.txt" ;
	echo -e "\techo \"=======================\" >> report.txt" ;
	echo -e "\techo \"==  VALGRIND REPORT  ==\" >> report.txt" ;
	echo -e "\techo \"=======================\" >> report.txt" ;
	echo -e "\tmake valgrind" ;
	echo -e "\tvalgrind ./helena-checker &>> report.txt" ;
	echo -e "" ;
	echo -e "clean:" ;
	echo -e "\trm helena-checker *.o *~") >> $makefile
    popd &> /dev/null
}

generateConfig () {
    checkExecutable $configGenerator
    $configGenerator $* $tmpDir || exitWithError
}

generateVectorsLib () {
    checkExecutable $vectorsGenerator
    $vectorsGenerator $tmpDir || exitWithError
}

generateLNA () {
    checkExecutable $lnaGenerator
    $lnaGenerator $* $tmpDir || exitWithError
}

generateDVE () {
    checkExecutable $dveGenerator
    $dveGenerator $* $tmpDir || exitWithError
}

generateChecker () {
    checkExecutable $checkerGenerator
    $checkerGenerator $tmpDir || exitWithError
}

collectReportFiles () {
    for i in $(seq 0 1000000)
    do
        grep "^\[xml-$i]" $xmlReportTmpFile | \
            sed "s/\[xml-[0-9]*\]//g" > report-$i.xml
        [ ! -s report-$i.xml ] && rm report-$i.xml && break
    done
}

launchChecker () {
    local dir=$(getModelDir)/src
    [ "$machineFile" != "" ] && cp "$machineFile" $dir/machinefile
    pushd $dir &> /dev/null
    msg "Launching search ($RUN comp-time $ccTime) ..."
    if [ $distributed -eq 0 ]
    then
        $RUN comp-time $ccTime
    else
        $RUN comp-time $ccTime | tee $xmlReportTmpFile | grep -v "^\[xml"
        collectReportFiles
        checkExecutable $reportsMerger
        $reportsMerger report-*.xml
    fi
    for f in $xmlReportFile $xmlGraphReportFile $graphFile
    do
        if [ -e $f ]
        then
	    mv $f ..
        fi
    done
    popd &> /dev/null
}

###############################################################################

#####
#  options
verbose=0
distributed=0
reportFile=""
machineFile=""

for arg in $*
do
    case $arg in
	-v|--verbose) verbose=1 ;;
	-h|--help) $configGenerator -h dummy dummy ; exit 0 ;;
	-V|--version) $configGenerator -V dummy dummy ; exit 0 ;;
	-md=*|--model-directory=*)
	    idx=$(expr index $arg =)
	    modelDir=${arg:$idx}
            ;;
	-A=*|--algo=*)
	    idx=$(expr index $arg =)
	    algo=$(echo ${arg:$idx} | tr [a-z] [A-Z])
	    if [ "$algo" = DDFS ]
	    then
		CC=$shcc
		distributed=1
	    fi
	    ;;
	-o=*|--report-file=*)
	    idx=$(expr index $arg =)
	    reportFile=${arg:$idx}
	    ;;
    esac
done
if [ $distributed -eq 1 ]
then
    for arg in $*
    do
        case $arg in
	    -mf=*|--machine-file=*)
	        idx=$(expr index $arg =)
	        machineFile=${arg:$idx}
                [ ! -e "$machineFile" ] && \
                    error "machine file '$machineFile' could not be found"
                RUN=$shrun" -machinefile machinefile "$RUN
                ;;
        esac
    done
    [ z"$machineFile" = z ] && \
        error "algorithm DDFS needs a machine file (option \
                --machine-file=FILE)"
fi

#####
#  check that model file exists and is readable
modelFile=$arg
[ "$modelFile" = "" ] &&  error "model file expected"
[ ! -f $modelFile -o ! -r $modelFile ] && \
    error "file $modelFile does not exist or is not readable"

createEnvironment

#####
#  generate model source files
mkdir $tmpDir
msg "Generating model source files ..."
generateConfig $*
generateVectorsLib
generateChecker
if [ -f model-options ]
then
    modelOptions=$(cat model-options)
    rm -rf model-options &> /dev/null
else
    modelOptions=""
fi
extension=$(echo $modelFile | awk -F "." '{print $NF}')
case $extension in
    lna)
	language=lna
	generateLNA $modelOptions $modelFile
	;;
    dve)
	language=dve
	CCopt=$CCopt" -fpack-struct"
	generateDVE $modelFile
	;;
    *)
	error "cannot determine type of input model"
	;;
esac

#####
#  get the model name, the C files generated for the model and the
#  object files generated for the model
if [ -f $tmpDir/MODEL -a -s $tmpDir/MODEL ]
then
    model=$(cat $tmpDir/MODEL)
else
    file=$(basename $modelFile)
    model=${file%.*}
fi
if [ -f $tmpDir/SRC_FILES -a -s $tmpDir/SRC_FILES ]
then
    modelSrcFiles=$(cat $tmpDir/SRC_FILES)
else
    modelSrcFiles=""
fi
if [ -f $tmpDir/OBJ_FILES -a -s $tmpDir/OBJ_FILES ]
then
    modelObjFiles=$(cat $tmpDir/OBJ_FILES)
else
    modelObjFiles=""
fi

#####
#  create the model directory and put in it files generated for the
#  model
[ -e $(getModelDir) ] && rm -rf $(getModelDir)
createDirectory $(getModelDir)
createDirectory $(getModelDir)/src
mv $tmpDir/* $(getModelDir)/src
rm -rf $tmpDir

#####
#  copy files to link (passed to helena with option --link) in the
#  source directory of the model
initLinks=$modelObjFiles
num=0
for arg in $*
do
    case $arg in
	-L=*|--link=*)
            idx=$(expr index $arg =)
	    inFile=${arg:$idx}
	    f=user_file_$num.o
	    num=$((num + 1))
	    cp $inFile $(getModelDir)/src/$f
	    initLinks=$initLinks" "$f
	    ;;
    esac
done

#####
#  compilation of all files
msg "Compiling source files ..."
startSec=$(date +"%s")
startNan=$(date +"%N")
CC=$CC" "$CCopt" -O3"
CC_GP=$CC" "$CCopt" -pg"
CC_VG=$CC" "$CCopt" -O0 -g"
cp $helenaDir/common/* $(getModelDir)/src/ &> /dev/null
compileCFiles
endSec=$(date +"%s")
endNan=$(date +"%N")
ccTime=$(echo "scale=2;$endSec-$startSec+($endNan-$startNan)/1000000000" | bc)
createMakefile
    
#####
#  execution and reporting
launchChecker
if [ -e $(getModelDir)/$xmlReportFile ]
then
    if [ ! -z "$reportFile" ]
    then
	cp $(getModelDir)/$xmlReportFile $reportFile
    fi
    checkExecutable $reporter
    $reporter $(getModelDir)/$xmlReportFile
fi
exit 0
